package org.example.progremmers;

public class Fatigue {
    static boolean[] visited; // 각 던전이 방문되었는지를 확인하는 배열
    static int count = 0;     // 유저가 탐험한 던전의 최대 수를 기록하는 변수

    // solution 함수는 주어진 피로도 k와 던전 목록을 받아 최대 던전 수를 반환하는 함수
    public int solution(int k, int[][] dungeons) {
        visited = new boolean[dungeons.length]; // 던전의 개수만큼 방문 여부 배열을 초기화
        dfs(0, k, dungeons); // dfs를 통해 탐험을 시작 (현재 피로도와 깊이 0부터 시작)
        return count; // 최대 탐험 던전 수를 반환
    }

    // dfs 함수는 깊이 우선 탐색(DFS)을 통해 던전을 탐험하는 함수
    private void dfs(int depth, int fatigue, int[][] dungeons) {
        // 모든 던전을 탐험할 때마다 시도
        for (int i = 0; i < dungeons.length; i++) {
            // 이미 방문한 던전이거나, 현재 피로도로 탐험할 수 없는 던전이라면 스킵
            if (visited[i] || dungeons[i][0] > fatigue) {
                continue; // 던전을 탐험할 수 없으면 넘어감
            }

            // 던전을 탐험하기로 결정
            visited[i] = true; // 던전 방문 처리

            // 다음 던전 탐험을 위해 재귀 호출 (현재 피로도에서 소모된 피로도만큼 차감)
            dfs(depth + 1, fatigue - dungeons[i][1], dungeons);

            // 탐험을 마친 후 해당 던전 방문을 취소
            visited[i] = false; // 백트래킹
        }

        // 현재까지 탐험한 던전 수(depth)가 기존의 최대 던전 수보다 많으면 갱신
        count = Math.max(count, depth); // 최대로 탐험한 던전 수를 갱신
    }

    public static void main(String[] args) {
         /* ==================================================================================================================================================================================
        XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다.
        이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다.
        "최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, "소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다.
        예를 들어 "최소 필요 피로도"가 80, "소모 피로도"가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다.

        이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다.
        유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때,
        유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.
        ================================================================================================================================================================================== */

        // Fatigue 클래스의 객체를 생성
        Fatigue fatigue = new Fatigue();

        // 첫 번째 테스트 케이스
        int k1 = 80; // 시작 피로도
        int[][] dungeons1 = {{80, 20}, {50, 40}, {30, 10}}; // 던전 정보 (최소 필요 피로도, 소모 피로도)
        System.out.println(fatigue.solution(k1, dungeons1)); // 출력: 3 (최대 탐험 가능 던전 수)

        // 두 번째 테스트 케이스
        int k2 = 10; // 시작 피로도
        int[][] dungeons2 = {{10, 5}, {15, 7}, {5, 3}}; // 던전 정보
        System.out.println(fatigue.solution(k2, dungeons2)); // 출력: 2 (최대 탐험 가능 던전 수)
    }
}

